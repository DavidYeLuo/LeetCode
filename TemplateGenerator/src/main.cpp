#include "Lexer.h"
#include "TemplateGenerator.h" // Generated by CMake. Might need to compile for clangd for completion
#include <cassert>
#include <cstdio>
#include <fstream>
#include <iostream>
#include <regex>
#include <sstream>
#include <string>

int main(int argc, char *argv[]) {
  std::string leetCodeName;
  std::string difficulty;
  std::string id;
  std::string url;

  leetCodeName = UI::prompt("Input leetCodeName: ");
  do {
    difficulty = UI::prompt("Input difficulty(easy:1, medium:2, hard:3): ");
  } while (difficulty != "1" && difficulty != "2" && difficulty != "3");
  id = UI::prompt("Input id: ");
  url = UI::prompt("Input url: ");

  std::ofstream fout_header;
  std::ofstream fout_src;
  std::ifstream fin_header;
  std::ifstream fin_src;

  std::string headerFile;
  std::string sourceFile;

  if (difficulty == "1") {
    headerFile = EASY_INCLUDE_PATH;
    sourceFile = EASY_SRC_PATH;
    difficulty = "Easy"; // Used for namespace in template
  } else if (difficulty == "2") {
    headerFile = MEDIUM_INCLUDE_PATH;
    sourceFile = MEDIUM_SRC_PATH;
    difficulty = "Medium"; // Used for namespace in template
  } else if (difficulty == "3") {
    headerFile = HARD_INCLUDE_PATH;
    sourceFile = HARD_SRC_PATH;
    difficulty = "Hard"; // Used for namespace in template
  }

  headerFile += "/" + leetCodeName + ".h";
  sourceFile += "/" + leetCodeName + ".cpp";

  fin_header.open(headerFile);
  fin_src.open(sourceFile);

  std::string response;

  if (fin_header.is_open() || fin_src.is_open()) {
    while (response != "y" && response != "n" && response != "Y" &&
           response != "N") {
      response = UI::prompt("Override existing file?(y/n): ");
    }
    if (response == "n" || response == "N") {
      printf("Closing.");
      fin_header.close();
      fin_src.close();
      return 0;
    }
  }

  // Open and check for template files
  std::ifstream fin_header_template;
  std::ifstream fin_src_template;
  fin_header_template.open(
      TEMPLATE_INCLUDE_PATH); // TEMPLATE_INCLUDE_PATH is the path to the file
  fin_src_template.open(
      TEMPLATE_SRC_PATH); // TEMPLATE_INCLUDE_PATH is the path to the file
  assert(fin_header_template.is_open()); // Checks if template exist
  assert(fin_src_template.is_open());    // Checks if template exist

  std::ostringstream oss_header;
  std::ostringstream oss_src;
  oss_header << fin_header_template.rdbuf();
  oss_src << fin_src_template.rdbuf();
  fin_header_template.close();
  fin_src_template.close();

  fout_header.open(headerFile);
  fout_src.open(sourceFile);

  std::string temp = std::regex_replace(
      oss_header.str(), std::regex("@LEETCODENAME@"), leetCodeName);
  temp = std::regex_replace(temp, std::regex("@DIFFICULTY@"), difficulty);
  fout_header << temp;

  temp = std::regex_replace(oss_src.str(), std::regex("@LEETCODENAME@"),
                            leetCodeName);
  temp = std::regex_replace(temp, std::regex("@DIFFICULTY@"), difficulty);
  fout_src << temp;

  fin_src.close();
  fin_header.close();
  fout_src.close();
  fout_header.close();

  return 0;
}

std::string UI::prompt(const char *message) {
  std::string input;
  std::cout << message;
  std::cin >> input;
  return input;
}
